<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="root"></div>

  <script>
    const crayonShinchan = ['짱구','짱아','흰둥이','유리','철수','맹구','훈이','수지'];
    const ShinchanArr = Array.from(crayonShinchan);
    console.log(Array.isArray(ShinchanArr));
    console.log(ShinchanArr);

    //Array Method

    //1.pop - 배열의 뒷부분 값을 삭제('수지'가 삭제됐다)
    // ShinchanArr.pop();
    // console.log(ShinchanArr);

    //2.push - 배열 뒷부분에 값을 삽입('이슬'이 맨 뒤에 추가됐다)
    // ShinchanArr.push('이슬');
    // console.log(ShinchanArr);

    //3.unshift - 배열 앞부분에 값을 삽입('초코비'가 맨 앞에 추가됐다)
    // ShinchanArr.unshift('초코비');
    // console.log(ShinchanArr);

    //4.shift - 배열 앞부분 값을 삭제(맨 앞 '짱구'가 삭제됐다)
    // ShinchanArr.shift();
    // console.log(ShinchanArr);

    //5.splice - 배열의 특정위치에 요소를 추가하거나 삭제
    // ShinchanArr.splice(3,2);
    // (3,2)는 3번째 인덱스에서부터 2개를 제거한다는 의미('유리','철수'가 삭제됐다)
    // console.log(ShinchanArr);

    // ShinchanArr.splice(3,1,"액션가면","돼지");
    // 3번째 인덱스에서부터 1개를 제거하고 그 자리에 "액션가면","돼지"를 추가한다는 의미('유리'가 삭제되고 '액션가면','돼지'가 추가됐다)
    // console.log(ShinchanArr);

    //6.slice - 배열의 startIndex부터 endIndex(이전)까지의 shallow copy를 새로운 배열 객체로 반환
    // let newShinchanArr = ShinchanArr.slice(5,7);
    //ShinchanArr의 5번째부터 7번째 이전 인덱스인 '맹구'(5번째),'훈이'(6번째)가 newShinchanArr의 배열 객체가 되었다
    // console.log('slice',newShinchanArr);

    //7.concat - 다수의 배열을 합치고 병합된 배열의 사본을 반환
    // let ShinchanSong1 = ['개미','는','뚠뚠'];
    // let ShinchanSong2 = ['오늘','도','둔둔'];
    // let ShinchanSong3 = ['열심히','일을','하네'];
    // let ShinchanSongs = ShinchanSong1.concat(ShinchanSong2, ShinchanSong3);
    // ShinchanSongs의 배열 객체는 Shinchansong1,2,3이 합쳐진 것이다
    // console.log(ShinchanSongs);

    //8.every - 배열의 모든 요소가 제공한 함수로 구현된 테스트를 통과하는지 테스트
    // let HiShinChan = function(value) {
    //   return value === "떡잎마을";
    //   반환값이 "떡잎마을"이라면 console.log에 true가 뜰 것
    // };
    // console.log(ShinchanArr.every(HiShinChan));
    // ShinchanArr의 배열 객체는 "떡잎마을"이 아니기 때문에 false가 뜬다

    //9.some - 지정된 함수의 결과가 true일 때까지 배열의 각 원소를 반복
    // let HiShinChan = function(value) {
    // return value === "짱아";
    // };
    // console.log(ShinchanArr.some(HiShinChan));
    //ShinchanArr의 배열 객체 중 하나라도 "짱아"가 있으면 true

    //10.forEach - 배열의 각 원소별로 지정된 함수를 실행한다
    // ShinchanArr.forEach(function(value) {
    // console.log(value);
    // 한번에 배열 객체를 보여주지 않고 한개씩 콘솔에 찍어준다
    // });

    //11.map - 배열의 각 원소별로 지정된 함수를 실행한 결과로 구성된 새로운 배열로 반환한다
    // let HiShinChan = function(value) {
    // return value = "짱구";
    // };
    // let newShinchanArr = ShinchanArr.map(HiShinChan);
    // console.log(newShinchanArr);
    // newShinchanArr는 ShinchanArr과 길이가 같지만 구성하는 배열 객체는 다 "짱구"가 되었다 (숫자와 계산식을 이용할 때 유용한 것 같음)

    //12.filter - 지정된 함수의 결과 값을 true로 만드는 원소들로만 구성된 별도의 배열을 반환
    // let HiShinChan = function(value){
    // return value === "흰둥이";
    // };
    // let newShinchanArr = ShinchanArr.filter(HiShinChan);
    // console.log(newShinchanArr);
    //newShinchanArr의 배열 객체는 "흰둥이"가 되었다 (숫자와 계산식을 이용할 때 유용한 것 같음)

    //13.reduce - 누산기(accumulator) 및 배열의 각 값(좌에서 우로)에 대해 (누산된)한 값으로 줄도록 함수를 적용
    // let numbers = [1,2,3,4,5,6,7,8,9,10];
    // let value = numbers.reduce(function (previousValue, currentValue, index) {
    // return previousValue + currentValue;
    // });
    // console.log(value);
    //numbers의 배열 객체를 좌부터 우로 다 더해(누산하여) 55가 되었다

    //14.reverse - 배열의 원소 순서를 거꾸로 바꿈
    // ShinchanArr.reverse();
    // console.log(ShinchanArr);
    //ShinchanArr 배열의 원소 순서가 거꾸로 바뀌었다

    //15.sort - 배열의 원소를 알파벳순, 또는 지정된 함수에 따른 순서로 정렬. 모든 원소를 문자열로 취급해 사전적으로 정렬
    // let numbers = [1,2,3,4,5,6,7,8,9,10];
    // numbers.sort();
    // console.log(numbers);
    // //사전적으로 정렬, 수의 크기에 상관없이 1이 앞에 붙어 있는 것이 먼저 정렬된다

    // numbers.sort(function(a,b) {
    // return a-b;
    // });
    // console.log(numbers);
    //??이건 뭐야 a-b를 했더니 원래대로 정렬이 되네??

    //16.toString - 배열을 문자열로 바꾸어 반환
    // let numbers = [1,2,3,4,5,6,7,8,9,10];
    // console.log(numbers.toString());
    //숫자 1~10이 문자열 1~10이 되었다

    //17.valueOf - 배열을 반환(?, 그대로 반환한다는 말인가?)
    // console.log(ShinchanArr);
    //배열 값을 그대로 반환한다는 것 같음

    //18.join - 배열 원소 전부를 하나의 문자열로 합침
    // console.log(ShinchanArr.join());
    // console.log(ShinchanArr.join('-'));
    //배열 원소가 다 하나의 문자열이 되었다

    //19.values - 배열의 각 인텍스에 대한 값을 가지는 새로운 Array Iteraotr 객체 반환
    // let HiShinChan = ShinchanArr.values();
    // console.log(HiShinChan.next());
    // console.log(HiShinChan.next());
    // console.log(HiShinChan.next());
    // console.log(HiShinChan.next());
    //?왜 false가 나오는지는 모르겠지만 순서대로 값을 알려준다

    //20.includes - 배열 값에 특정 값이나 특정 문자가 포함되어 있는지 확인
    // console.log(ShinchanArr.includes("유리"));
    // console.log(ShinchanArr.includes("이슬"));
    //"유리"는 ShinchanArr 배열 객체로 포함되어있어 ture가 찍히지만 "이슬"은 없기때문에 false가 찍힌다

    //21.findIndex - 판별 함수를 만족하는 첫 식별자를 반환, 원하는 요소를 찾자마자 메서드 종료
    // let numbers = [1,2,3,4,5,6,7,8,9,10];
    // let jjak = numbers.findIndex((num) => num%2 === 0);
    // console.log(jjak);
    //??이해 안됌

    //22.at - 길이로 원하는 배열 요소에 접근
    //  console.log(ShinchanArr.at(-1));
    //  console.log(ShinchanArr.at(-2));
    //  console.log(ShinchanArr.at(1));
    //  console.log(ShinchanArr.at(2));
    //위부터 순서대로 '수지','훈이','짱아','흰둥이'가 찍힌다

    //23.from과 24.isArray
    //const crayonShinchan = ['짱구','짱아','흰둥이','유리','철수','맹구','훈이','수지'];
    //사실 crayonShinchan은 배열로 보일 뿐 진짜 배열이 아닌 유사배열객체다

    // const ShinchanArr = Array.from(crayonShinchan);
    //그래서 Array.from을 통해 crayonShinchan을 진짜 배열로 취급할 수 있게 만든다

    // console.log(Array.isArray(ShinchanArr));
    //Array.isArray를 통해 확인하면 true가 나와 배열로 취급하게 됐다는 걸 알 수 있다

    //25.indexOf - 배열에서 특정 문자를 검색하여 위치 반환
    //  console.log(ShinchanArr.indexOf("철수"));
    //  console.log(ShinchanArr.indexOf("훈이"));
     //배열 순서대로 '철수'는 4번째, '훈이'는 6번째에 있다고 알려준다 

  </script>
</body>
</html>